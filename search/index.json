[{"content":"CPP中的重定向printf cpp不允许重定义 =\u0026gt; 不按照cpp规则编译即可\n1 2 3 4 5 6 7 8 extern \u0026#34;C\u0026#34; { int fputc(int ch, FILE *f) { HAL_UART_Transmit(\u0026amp;huart3, (uint8_t *)\u0026amp;ch, 1, 0xFFFF); return ch; } } LED控制亮度 =\u0026gt; LED 类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 class Led { private: TIM_HandleTypeDef *__htim__; unsigned int __ch__; int __max__ = 255; int __diff__ = 10; int CrtTask = 0; int CrtBreathStatus = 0; public: int crt; Led(TIM_HandleTypeDef *htim, unsigned int ch) { __htim__ = htim; __ch__ = ch; }; ~Led() { __HAL_TIM_SET_COMPARE(__htim__, __ch__, 0); }; void set(int compare) { if (compare \u0026lt; 0) { compare = 0; } else if (compare \u0026gt; __max__) { compare = __max__; } crt = compare; __HAL_TIM_SetCompare(__htim__, __ch__, compare); } void reset() { set(0); CrtTask = 0; CrtBreathStatus = 0; } void toggle(int compare) { if (crt == 0) { set(compare); } else { reset(); } } bool minus(int diff) { if (crt == 0) { return false; } else { set(crt - diff); return true; } } bool add(int diff) { if (crt == __max__) { return false; } else { set(crt + diff); return true; } } bool TryBreath(int diff, bool always = true) { switch (CrtBreathStatus) { case 1: if (!add(diff)) { CrtBreathStatus = 2; } return true; case 2: if (!minus(diff)) { if (always) { CrtBreathStatus = 1; } else { reset(); } } return true; default: return false; } } void setTask(int task) { CrtTask = task; } void execTask() { switch (CrtTask) { case 1: add(__diff__); break; case 2: minus(__diff__); break; case 3: if (CrtBreathStatus == 0) CrtBreathStatus = 1; TryBreath(__diff__); break; case 4: if (CrtBreathStatus == 0) CrtBreathStatus = 1; TryBreath(__diff__, false); break; case 0: break; default: break; } } }; LED类 =\u0026gt; LED Array 类 简单的将上面的LED用array来 遍历 控制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 template \u0026lt;size_t N\u0026gt; class LedArray { public: std::array\u0026lt;Led, N\u0026gt; __leds__; unsigned int __size__; LedArray(std::array\u0026lt;Led, N\u0026gt; \u0026amp;leds) : __leds__(leds), __size__(N){}; ~LedArray() { for (Led \u0026amp;led : __leds__) { led.reset(); } }; void resetAll() { for (Led \u0026amp;led : __leds__) { led.reset(); } } void printCompares() { int i = 0; for (Led \u0026amp;led : __leds__) { printf(\u0026#34;index: %d, compare: %d\\n\u0026#34;, i, led.crt); i += 1; } } void setCompares(int compares[]) { customAssert(getArrayLength(compares), __size__, Comparison::Equal); int i = 0; for (Led \u0026amp;led : __leds__) { led.set(compares[i]); i += 1; } } void toggleLeds(int compares[]) { customAssert(getArrayLength(compares), __size__, Comparison::Equal); int i = 0; for (Led \u0026amp;led : __leds__) { if (compares[i]) { led.toggle(compares[i]); } i += 1; } } void setTasks(int tasks[]) { customAssert(getArrayLength(tasks), __size__, Comparison::Equal); int i = 0; for (Led \u0026amp;led : __leds__) { led.setTask(tasks[i]); i += 1; } } void execTasks() { for (Led \u0026amp;led : __leds__) { led.execTask(); } } }; 延时执行类 Delay 为了实现 流水 效果， 需要延时(每隔几次运行一次)来执行\nhpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Delay { public: Delay(int delayTimes = 5, bool first = true); ~Delay(); void reset(); void ctn(); bool exceed(); private: int __delay_times__; int __crt_times__; }; cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Delay::Delay(int delayTimes, bool first) : __delay_times__(delayTimes), __crt_times__(delayTimes) {} Delay::~Delay() { __delay_times__ = 0; } void Delay::reset() { __crt_times__ = 0; } void Delay::ctn() { __crt_times__ += 1; } bool Delay::exceed() { if (__crt_times__ \u0026gt;= __delay_times__) { reset(); return true; } else { ctn(); return false; } } ##　串口屏控制(状态控制和直接控制) 这里的状态一是Crt_Main_Task, 也就写了个流水，二是每个灯独立的状态控制，用到的也就一个 呼吸。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 void reset_whole() { Crt_Main_Task = 0; CrtLedIndex = 0; ledarray.resetAll(); delay_20.reset(); } void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if (huart == \u0026amp;huart1) { __HAL_UART_CLEAR_IT(\u0026amp;huart1, UART_CLEAR_IDLEF); __HAL_UART_DISABLE_IT(\u0026amp;huart1, UART_IT_TXE); Crt_Main_Task = 0; switch (rev_data[0]) { // 全关复位 case 0x01: reset_whole(); break; // 设置亮度 case 0x02: int compares[8]; for (int i = 0; i \u0026lt; 8; i++) { compares[i] = rev_data[i + 1]; } ledarray.setCompares(compares); break; // 亮灭互转且设置亮度 case 0x03: int toggles[8]; for (int i = 0; i \u0026lt; 8; i++) { toggles[i] = rev_data[i + 1]; } ledarray.toggleLeds(toggles); break; // 呼吸(逐渐亮/暗) case 0x04: int tasks[8]; for (int i = 0; i \u0026lt; 8; i++) { tasks[i] = 3 * rev_data[i + 1]; } ledarray.setTasks(tasks); break; // 流水呼吸 case 0x05: Crt_Main_Task = 1; // 这个函数用来处理各led的顺序大小然后重新排序 sortVectorByValue(rev_data, 8, Blink_Leds, Blink_Cnt); } __HAL_UART_ENABLE_IT(\u0026amp;huart1, UART_IT_TXE); HAL_UART_Receive_IT(\u0026amp;huart1, rev_data, 9); __HAL_UART_FLUSH_DRREGISTER(\u0026amp;huart1); __HAL_UART_CLEAR_FLAG(\u0026amp;huart1, UART_FLAG_RXNE); } } 上面的sortVectorByValue，这直接 Ai 写吧，先排个序然后再判断相邻的是不是相等就行了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void sortVectorByValue(const uint8_t vec[], int size, int sortedIndices[][MAX_SIZE], int \u0026amp;count) { count = 0; for (int i = 0; i \u0026lt; MAX_SIZE; i++) { for (int j = 0; j \u0026lt; MAX_SIZE; j++) { sortedIndices[i][j] = -1; } } Pair indexedVec[MAX_SIZE]; for (int i = 0; i \u0026lt; size; i++) { indexedVec[i].index = i; indexedVec[i].value = (int)vec[i + 1]; } std::sort(indexedVec, indexedVec + size, compareByValue); int subArray[MAX_SIZE]; int subCount = 0; int prevValue = indexedVec[0].value; for (int i = 0; i \u0026lt; size; i++) { if (indexedVec[i].value == prevValue) { subArray[subCount++] = indexedVec[i].index; } else { for (int j = 0; j \u0026lt; subCount; j++) { sortedIndices[count][j] = subArray[j]; } count++; subCount = 0; subArray[subCount++] = indexedVec[i].index; prevValue = indexedVec[i].value; } } for (int j = 0; j \u0026lt; subCount; j++) { sortedIndices[count][j] = subArray[j]; } count++; } 定时执行(执行状态对应的任务) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim == \u0026amp;htim2) { // 执行Crt_Main_Task对应的任务，这个其实可以再拆一个 类 出来，但是没有更多功能要写, // 先扔这里了。 switch (Crt_Main_Task) { case 1: // 延时开启下一组led的呼吸任务 if (delay_20.exceed()) { if (CrtLedIndex \u0026gt;= Blink_Cnt) { CrtLedIndex = 0; } else { for (int \u0026amp;index : Blink_Leds[CrtLedIndex]) { if (index \u0026gt;= 0 \u0026amp; index \u0026lt; 8) { ledarray.__leds__[index].setTask(4); } } CrtLedIndex += 1; } } break; default: break; } // 执行所有的led的任务 ledarray.execTasks(); // 隔一段时间输出一下led的状态 if (delay_30.exceed()) ledarray.printCompares(); } } ","date":"2023-10-07T00:00:00Z","permalink":"https://canxin121.github.io/p/led%E7%81%AF%E6%8E%A7%E5%88%B6usart/","title":"Led灯控制(Usart)"},{"content":"保命事项 VCC等电压和GND接地千万不要接反! 否则板子升天, money打水漂. 元器件列表 感谢物院实验室某佬倾情相借!\nStm32 H750VBT6 轮趣科技 Tb6612 稳压版电机驱动 轮趣科技 MG513 霍尔解码器版电机 TJC3224K024 触控屏 PWlink2 lite版本 下载\\调试器 一块电池 使用工具 Vscode ＋ EIDE套装 Keil u5( Stm Cube MX USART HMI (TJC图形化编程工具) 实践过程 接线 电机 和 驱动板接线, 这里直接使用附赠的排线连接. 驱动板 和 Stm主板 接线 ( 可以按照自己喜欢的布局连接, 也可以参考驱动板厂家给出的示例. 显示屏 和 Stm主板 接线 (TX,RX对接就完了), 这里电池给显示屏供电, 所以直接接到了驱动板引出的5v和GND. Pwlink2lite下载器 和 Stm主板 接线( 这里要单独接一个TX-\u0026gt;RX, 用来输出调试信息). 这里简单介绍下不同串口的接线意义:\n驱动板和Stm 驱动板的 E2A和E2B (这里的2代表用的第二个电机,也就是B电机,\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026quot;代表编码器的A相和B相) 接 Stm 的 两个Pin设定同一个TIM并且将该TIM设定为Combined Mode下的Encoder Mode用来解码从电机获取的实际转速(这里实际是 固定时间的位移 正比于速度, 可以当成转速来用) 驱动板的 ADC 接口 (这里是用来读取电压) 接 Stm 的 Pin 设定为 ADC_IN.(呃呃,这里最后其实没把电压显示出来,所以没用上) 驱动板的 PWMB (这里的B就是代表B电机了) 接 Stm 的 Pin 设定为 TIM 并将对应 TIM 的 对应 CH 设定为PWM GENERATION CHx, 用来输出PWM信号 驱动版的 BIN1,2 接 Stm 的 Pin 设定为 GPIO OUTput, 用来设定电机旋转的模式 还有其他的使能,电源接口就不赘述了.可以查看 驱动板的使用说明\n触控屏和Stm 触控屏使用UART通信, TX,RX 和 Stm 对接(小白注意嗷,TX-\u0026gt;RX对接), Stm上的 两个Pin 设置RX,TX(这里用的USART), 并且要打开对应USART的NVIC (中断) Stm和 PwLink2lite 下载器 调试下载的直接对应相连, 电压接3v3, GND对接 Pwlink2lite 的 Rx 接到Stm 的 Pin 设置为 USART TX, 用来发送调试信息(后面的代码部分会提到Printf的重定向) Stm Cube MX 配置 这里的创建工程略过, 小白可以自己看看MX的教学视频\n串口设定(Pin OUT) 这里的串口要对应好自己的实际接线. 串口相应功能设定 这些功能要对应好你实际的串口设定\nTIM ADC GPIO USART ![发送调试信息到Pwlink2lite的Usart把Mode打开成Async就好]\nProject Manager 然后配置一下生成代码的设置, 让它生成单独的c/h文件, 并且生成MDK(Keil)的源代码, 这样后面的VSC + EIDE可以直接以MDK项目格式导入进去,嘎嘎方便. USART HMI 写/刷 触控屏程序 小白可以先看看这个系列教程了解一下这个 陶晶驰的图形化设计软件的使用方法\n点击上面可以跳转到完整的系列视频⬆️⬆️⬆️\n下面是正文⬇️⬇️⬇️\n我设计的简陋的界面 这里面唯一有用的就是func界面了(其他纯属引流嗷,建议别学我嗷 首先需要两个数字框(绑定数字键盘), 一个用来设定目标速度,一个用来设定目标圈数,并且设定了初始值 然后加个复选框来 选择 正转 or 反转 然后加两个按钮, 一个start 一个 stop, 本质都是用uart发一些数据 这里两个按钮需要自己定义一个简单的通信协议, 我这里是这样极其简陋乱写的\n也就是 [-1,速度的整数,-2,圈数的整数,-3,复选框(正/反转)的整数]\n搞定程序设计我们调试试一下效果,没有问题就可以把 屏幕用下载器接到电脑(自己简单对接可以)\nVscode + EIDE 环境配置 小白直接看这个教程吧 控制代码 EIDE 导入项目后 开始写代码\n这里由于程序简单, 我直接全写在main.c了\n这里注意一定要在 BEGIN 和 END 中间来写自己的代码, 否则CubeMX再次生成代码时, 会把你非用户代码区的代码删掉了.\n下面的代码中也只有 BEGIN 和 END 中间的代码是开发者自己写的,其他全部由CubeMX自动生成\ninclude 这里只用到了一个pid(这个代码分享在最后吧), 一个stdio(使用printf)\n1 2 3 4 /* USER CODE BEGIN Includes */ #include \u0026#34;pid.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; /* USER CODE END Includes */ 用uart重定向printf到调试器 这个记住就好啦, 网上抄来的方法, 确实不错的方案\n1 2 3 4 5 6 7 8 int fputc(int ch, FILE *f) { // 使用HAL库函数HAL_UART_Transmit将字符ch发送到UART4串口 HAL_UART_Transmit(\u0026amp;huart4, (uint8_t *)\u0026amp;ch, 1, 0xFFFF); // 返回发送的字符，这通常不会有实际的影响，但是它需要返回发送的字符。 return ch; } main函数 初始化一些参数, 并初始化一个PID计算的结构体 把屏幕控制的USART打开来接受信息, 并且设置每接受六次产生一次中断(因为上面的串口屏是设定的发送6个整数) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* USER CODE BEGIN 0 */ // 定义一个全局的PID结构体,用来计算PID的时候传参 struct PID_struct pid; // 定义一个buf用来储存从屏幕的uart收到的消息(发了6个整数) uint8_t rev_data[6]; /* USER CODE END 0 */ /** * @brief The application entry point. * @retval int */ int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM3_Init(); MX_ADC1_Init(); MX_TIM2_Init(); MX_TIM4_Init(); MX_UART4_Init(); MX_USART1_UART_Init(); /* USER CODE BEGIN 2 */ // 这里是一个坑, 详情请看下面的PWM部分的Read_Encoder() TIM2-\u0026gt;CNT = 0x7FFF; // 把屏幕的UART的接受消息打开, HAL_UART_Receive_IT(\u0026amp;huart1, rev_data, 6); // 把PID结构体初始化,这里的P I D参数要看自己选择合适的值, 可以根据实际情况适当调节. float Incremental_KP = 3, Incremental_KI = 0.5, Incremental_KD = 1; // 调用PID初始化函数(这个代码我放在结尾吧, 作者是物院实验室某佬) // 这里最后两个参数是限定I项的, 具体左右可以看代码 PID_init(\u0026amp;pid, Incremental_KP, Incremental_KI, Incremental_KD, 10, 10); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 屏幕串口的UART中断 我们通过重定义中断回调函数来实现对HAL的中断回调的使用\n下面的代码 通过 屏幕串口USART中断来实现 不同状态下 激活/关闭 计时器和电机\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // 这里定义一些变量 // 电机转一圈所需的Encoder读数累和 int Each_Circle = 1440; // 设定的目标速度 Encoder读出的真实速度 int Target_Velocity = 0, Reality_Velocity = 0; // 设定的目标位置总读数和 实际位置读数和 int Target_Position = 0, Reality_Position = 0; // 给电机的PWM设定的占空比数值(这里需要每次累加,因为使用的是增程式pid) int Set_Velocity = 0; void Start_TIM(void) { // Start Encoder tim 开启解码器时钟 HAL_TIM_Encoder_Start(\u0026amp;htim2, TIM_CHANNEL_ALL); // Start Time Control tim 开启定时控制的时钟 HAL_TIM_Base_Start_IT(\u0026amp;htim4); // Start the pwm tim 开启pwm输出的时钟 HAL_TIM_PWM_Start(\u0026amp;htim3, TIM_CHANNEL_3); } void Stop_TIM(void) { // 重置各种参数。 防止下次启动时有上次残留的值 Target_Velocity = 0; Reality_Velocity = 0; Target_Position = 0; Reality_Position = 0; Set_Velocity = 0; // Stop Encoder tim 关闭解码器时钟 HAL_TIM_Encoder_Stop(\u0026amp;htim2, TIM_CHANNEL_ALL); // Stop Time Control tim 关闭定时控制的时钟 HAL_TIM_Base_Stop_IT(\u0026amp;htim4); // Stop the pwm tim 关闭pwm输出的时钟 HAL_TIM_PWM_Stop(\u0026amp;htim3, TIM_CHANNEL_3); } // 这个函数用来设定电机 正转/反转/不转/刹车 void MoTo(int mode) // 这里需要对照你的接线来设定,BIN1和BIN2对应的不同状态状态可以在驱动的说明中找到 // 同时也要对应好 屏幕设定的 复选框 发送的0/1对应的正反转 /* 1 foreward 0 reversal -1 stop -2 brake */ { switch (mode) { case 1: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_SET); break; case 0: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_RESET); break; case -1: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_RESET); break; case -2: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_SET); break; default: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_RESET); break; } } void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { // 这是HAL库提供的UART接收完成回调函数，当UART接收完成时，该函数会被自动调用。 // 判断是哪个UART触发了回调，这里使用了单个UART1，可以根据实际情况进行扩展。 if (huart == \u0026amp;huart1) { // 清除空闲中断标志位，UART通信中，空闲中断通常用于检测接收结束。 __HAL_UART_CLEAR_IT(\u0026amp;huart1, UART_CLEAR_IDLEF); // 禁用UART发送中断，以防止在处理接收数据时发送数据。 __HAL_UART_DISABLE_IT(huart, UART_IT_TXE); // 检查接收到的数据是否符合预期的协议，如果传输中出错了,就直接跳过不执行,根据协议格式解析数据。 // -1 -2 -3 if (rev_data[0] == 0xFF \u0026amp;\u0026amp; rev_data[2] == 0xFE \u0026amp;\u0026amp; rev_data[4] == 0xFD) { // 从接收到的数据中提取速度、圈数和模式信息。 int speed = rev_data[1]; int circle = rev_data[3]; int mode = rev_data[5]; // 检查速度和圈数是否都不为零，才需要转动。 if (speed != 0 \u0026amp;\u0026amp; circle != 0) { // 如果目标速度和位置都为零，则说明当前没有进行任何动作，可以开始新的动作。 if (Target_Velocity == 0 \u0026amp;\u0026amp; Target_Position == 0) { // 设置目标速度和目标位置。 Target_Velocity = speed; Target_Position = circle * Each_Circle; // 根据模式调用MoTo函数执行相应的操作。 // MoTo 函数定义时要把屏幕传过来的 (0/1) 和 真实转动的对应正确 MoTo(mode); // 启动定时器,这样其他的中断才会发生。 Start_TIM(); } } else { // 如果速度或圈数为零，就说明要停下电机。 MoTo(-2); // 调用MoTo函数执行刹停电机。 // 重置各种参数(防止下次启动时有上次残留的值) 并且 停止定时器。 Stop_TIM(); } } // 重新启用UART发送中断，以便后续可以发送数据。 __HAL_UART_ENABLE_IT(huart, UART_IT_TXE); // 重新启用UART接收中断，以便继续接收数据。 HAL_UART_Receive_IT(\u0026amp;huart1, rev_data, 6); // 清空UART的数据寄存器，以确保不会因为残留数据而触发接收中断。 __HAL_UART_FLUSH_DRREGISTER(\u0026amp;huart1); // 清除UART接收缓冲区非空标志位，以确保下一次接收可以正常触发中断。 __HAL_UART_CLEAR_FLAG(\u0026amp;huart1, UART_FLAG_RXNE); } } 固定时间间隔的 中断控制 之所以要新开一个 tim, 固定时间的读取encoder并设定pwm, 是为了\nencoder读出的实际可以理解为转动的总距离, 只有时间间隔固定, 我们才能将固定时间的 转动距离差 当作 速度来用 防止过快的设置pwm, 别把电机玩坏了( 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 这里读取encoder有一个坑 // 由于这个encoder是一直累加(或减,取决于电机正反转)的, 它累加到最大值(减到0) 就自动重置了 // 因此你上一次读的数 不一定比 这次读的数大, 这样一算差值, 就可能出现一个极其大的负值 // 为了防止这种情况, 我们就需要把这个 tim 的读数一开始(main里面就设置了) // 就设定到一个 中间数值(0和最大之间), 并且 每次读完之后都把它设定回去 // 这样就能保证每次都得到一个 计算正确的 值 int16_t Read_Encoder(void) { int16_t count = __HAL_TIM_GET_COUNTER(\u0026amp;htim2); TIM2-\u0026gt;CNT = 0x7FFF; count -= 0x7FFF; // 这里因为电机 正传反转 有一种情况是累加,一种是累减, 所以有正有负 // 但是计算pid并设置pwm都是正值, 所以返回绝对值 if (count \u0026lt; 0) { return count * -1; } else { return count; } } // 固定时间间隔的 中断控制, 每0.1秒多执行一次 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim == \u0026amp;htim4) { // 读取实际转速(相当于转速) Reality_Velocity = Read_Encoder(); // 转速累和相当于总距离(实际上转速使用这个总距离做差才算出来的,前面已经解释过了) Reality_Position += Reality_Velocity; // 每次先判断是不是已经到了设定的要转的总距离, 如果是, 刹车关定时器重置相关参数 if (Reality_Position \u0026gt;= Target_Position) { // 刹车 MoTo(-2); // 停止计时器 Stop_TIM(); } // 用PID算法计算出要设定的pwm值 Set_Velocity += PID(\u0026amp;pid, Target_Velocity, Reality_Velocity); // 这里串口输出一下调试信息,方便查看 printf(\u0026#34;target: %d, real: %d, set: %d\\n\u0026#34;, Target_Velocity, Reality_Velocity, Set_Velocity); // 设定pwm值 Set_Pwm(Set_Velocity); } } 相关代码分享 pid 由某物院实验室佬手写\npid.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #ifndef __PID_H_ #define __PID_H_ #define MAX_LEN 15 struct PID_struct { float KP; float KI; float KD; float DATA[MAX_LEN]; float MAX_I; int LEN; int is_first; // 解决D的首次误差减去0得到一个不正常的D值问题 int top_index; }; void PID_init(struct PID_struct *pid_struct, float kp, float ki, float kd, int len, int max_i); float PID(struct PID_struct *pid_struct, float tar, float cur); #endif pid.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 /** * @file PID * @author zl (2293721550@qq.com) * @brief 一个通用的PID函数，该PID接收返回数据全部为float类型 * 使用时先构造PID_struct类型的结构体，再调用PID_init()函数初始化结构体，最后调用PID()函数得到PID的返回值 * @version 0.1 * @date 2023-08-24 * * @copyright Copyright (c) 2023 * */ #include \u0026#34;pid.h\u0026#34; /** * @brief 初始化PID结构体 * * @param pid_struct 想要初始化的PID结构体指针 * @param kp P项比例系数 * @param ki I项比例系数 * @param kd D项比例系数 * @param len I积分项长度(不能超过MAX_LEN的设定值) * @param max_i I项最大输出量,防止出现积分量过大导致的过冲 */ void PID_init(struct PID_struct *pid_struct, float kp, float ki, float kd, int len, int max_i) { pid_struct-\u0026gt;KP = kp; pid_struct-\u0026gt;KI = ki; pid_struct-\u0026gt;KD = kd; pid_struct-\u0026gt;LEN = len; pid_struct-\u0026gt;MAX_I = max_i; pid_struct-\u0026gt;is_first = 1; pid_struct-\u0026gt;top_index = MAX_LEN - 1; } /** * @brief 求出积分项值 * * @param pid_struct 想要处理的PID结构体指针 * @return float */ float err_sum(struct PID_struct *pid_struct) // 获取I值 { float buf = 0; for (int i = 0; i \u0026lt; MAX_LEN; i++) buf += pid_struct-\u0026gt;DATA[i]; return buf; } /** * @brief 求出微分项值 * * @param pid_struct 想要处理的PID结构体指针 * @return float */ float err_change(struct PID_struct *pid_struct) // 获取D值 { float change_speed = 0; if (pid_struct-\u0026gt;is_first != 1) if (pid_struct-\u0026gt;top_index == 0) change_speed = pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index] - pid_struct-\u0026gt;DATA[MAX_LEN - 1]; else change_speed = pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index] - pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index - 1]; else pid_struct-\u0026gt;is_first = 0; return change_speed; } /** * @brief PID函数 * * @param pid_struct 想要处理的PID结构体指针 * @param tar 目标值 * @param cur 当前值 * @return float 返回PID计算后的值 */ float PID(struct PID_struct *pid_struct, float tar, float cur) { float pid = 0; float err = tar - cur; float P = 0; float I = 0; float D = 0; pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index] = err; // PID数据先进先出 if (pid_struct-\u0026gt;top_index - pid_struct-\u0026gt;LEN \u0026gt;= 0) pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index - pid_struct-\u0026gt;LEN] = 0; else pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index - pid_struct-\u0026gt;LEN + MAX_LEN] = 0; P = pid_struct-\u0026gt;DATA[pid_struct-\u0026gt;top_index]; // 获取PID三值 I = err_sum(pid_struct); D = err_change(pid_struct); pid_struct-\u0026gt;top_index++; // 数据头向前移动一个 if (pid_struct-\u0026gt;top_index \u0026gt;= MAX_LEN) pid_struct-\u0026gt;top_index = 0; if (I * pid_struct-\u0026gt;KI \u0026gt; pid_struct-\u0026gt;MAX_I) I = pid_struct-\u0026gt;MAX_I / pid_struct-\u0026gt;KI; else I = I; // 限制I的累计不可大于MAX_I pid = P * pid_struct-\u0026gt;KP + I * pid_struct-\u0026gt;KI + D * pid_struct-\u0026gt;KD; // 计算出PID的返回值 return pid; } 完整的main.c程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 /* USER CODE BEGIN Header */ /** ****************************************************************************** * @file : main.c * @brief : Main program body ****************************************************************************** * @attention * * Copyright (c) 2023 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS-IS. * ****************************************************************************** */ /* USER CODE END Header */ /* Includes ------------------------------------------------------------------*/ #include \u0026#34;main.h\u0026#34; #include \u0026#34;adc.h\u0026#34; #include \u0026#34;tim.h\u0026#34; #include \u0026#34;usart.h\u0026#34; #include \u0026#34;gpio.h\u0026#34; /* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include \u0026#34;pid.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; /* USER CODE END Includes */ /* Private typedef -----------------------------------------------------------*/ /* USER CODE BEGIN PTD */ /* USER CODE END PTD */ /* Private define ------------------------------------------------------------*/ /* USER CODE BEGIN PD */ /* USER CODE END PD */ /* Private macro -------------------------------------------------------------*/ /* USER CODE BEGIN PM */ /* USER CODE END PM */ /* Private variables ---------------------------------------------------------*/ /* USER CODE BEGIN PV */ /* USER CODE END PV */ /* Private function prototypes -----------------------------------------------*/ void SystemClock_Config(void); /* USER CODE BEGIN PFP */ /* USER CODE END PFP */ /* Private user code ---------------------------------------------------------*/ /* USER CODE BEGIN 0 */ // redirect `printf` int fputc(int ch, FILE *f) { // 使用HAL库函数HAL_UART_Transmit将字符ch发送到UART4串口 HAL_UART_Transmit(\u0026amp;huart4, (uint8_t *)\u0026amp;ch, 1, 0xFFFF); // 返回发送的字符，这通常不会有实际的影响，但是它需要返回发送的字符。 return ch; } // uint16_t Get_adc(void) // { // HAL_ADC_Start(\u0026amp;hadc1); // HAL_ADC_PollForConversion(\u0026amp;hadc1, 2); // if (HAL_IS_BIT_SET(HAL_ADC_GetState(\u0026amp;hadc1), HAL_ADC_STATE_REG_EOC)) // { // return HAL_ADC_GetValue(\u0026amp;hadc1); // } // else // { // return Get_adc(); // } // } // uint16_t Get_adc_Average(uint8_t times) // { // uint32_t sum = 0; // for (uint8_t i = 0; i \u0026lt; times; i++) // { // sum += Get_adc(); // } // return sum / times; // } // define pid struct struct PID_struct pid; // the buf for screen usart uint8_t rev_data[6]; /* USER CODE END 0 */ /** * @brief The application entry point. * @retval int */ int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_TIM3_Init(); MX_ADC1_Init(); MX_TIM2_Init(); MX_TIM4_Init(); MX_UART4_Init(); MX_USART1_UART_Init(); // 这里是一个坑, 详情请看下面的PWM部分的Read_Encoder() TIM2-\u0026gt;CNT = 0x7FFF; // 把屏幕的UART的接受消息打开, HAL_UART_Receive_IT(\u0026amp;huart1, rev_data, 6); // 把PID结构体初始化,这里的P I D参数要看自己选择合适的值, 可以根据实际情况适当调节. float Incremental_KP = 3, Incremental_KI = 0.5, Incremental_KD = 1; // 调用PID初始化函数(这个代码我放在结尾吧, 作者是物院实验室某佬) // 这里最后两个参数是限定I项的, 具体左右可以看代码 PID_init(\u0026amp;pid, Incremental_KP, Incremental_KI, Incremental_KD, 10, 10); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } /** * @brief System Clock Configuration * @retval None */ void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct = {0}; RCC_ClkInitTypeDef RCC_ClkInitStruct = {0}; /** Supply configuration update enable */ HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY); /** Configure the main internal regulator output voltage */ __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3); while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) { } /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_DIV1; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 9; RCC_OscInitStruct.PLL.PLLP = 2; RCC_OscInitStruct.PLL.PLLQ = 2; RCC_OscInitStruct.PLL.PLLR = 2; RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3; RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOMEDIUM; RCC_OscInitStruct.PLL.PLLFRACN = 3072; if (HAL_RCC_OscConfig(\u0026amp;RCC_OscInitStruct) != HAL_OK) { Error_Handler(); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2; RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1; if (HAL_RCC_ClockConfig(\u0026amp;RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); } } /* USER CODE BEGIN 4 */ // 这里定义一些变量 // 电机转一圈所需的Encoder读数累和 int Each_Circle = 1440; // 设定的目标速度 Encoder读出的真实速度 int Target_Velocity = 0, Reality_Velocity = 0; // 设定的目标位置总读数和 实际位置读数和 int Target_Position = 0, Reality_Position = 0; // 给电机的PWM设定的占空比数值(这里需要每次累加,因为使用的是增程式pid) int Set_Velocity = 0; void Start_TIM(void) { // Start Encoder tim 开启解码器时钟 HAL_TIM_Encoder_Start(\u0026amp;htim2, TIM_CHANNEL_ALL); // Start Time Control tim 开启定时控制的时钟 HAL_TIM_Base_Start_IT(\u0026amp;htim4); // Start the pwm tim 开启pwm输出的时钟 HAL_TIM_PWM_Start(\u0026amp;htim3, TIM_CHANNEL_3); } void Stop_TIM(void) { // 重置各种参数。 防止下次启动时有上次残留的值 Target_Velocity = 0; Reality_Velocity = 0; Target_Position = 0; Reality_Position = 0; Set_Velocity = 0; // Stop Encoder tim 关闭解码器时钟 HAL_TIM_Encoder_Stop(\u0026amp;htim2, TIM_CHANNEL_ALL); // Stop Time Control tim 关闭定时控制的时钟 HAL_TIM_Base_Stop_IT(\u0026amp;htim4); // Stop the pwm tim 关闭pwm输出的时钟 HAL_TIM_PWM_Stop(\u0026amp;htim3, TIM_CHANNEL_3); } // 这个函数用来设定电机 正转/反转/不转/刹车 void MoTo(int mode) // 这里需要对照你的接线来设定,BIN1和BIN2对应的不同状态状态可以在驱动的说明中找到 // 同时也要对应好 屏幕设定的 复选框 发送的0/1对应的正反转 /* 1 foreward 0 reversal -1 stop -2 brake */ { switch (mode) { case 1: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_SET); break; case 0: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_RESET); break; case -1: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_RESET); break; case -2: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_SET); break; default: HAL_GPIO_WritePin(GPIOB, BIN1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, BIN2_Pin, GPIO_PIN_RESET); break; } } void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { // 这是HAL库提供的UART接收完成回调函数，当UART接收完成时，该函数会被自动调用。 // 判断是哪个UART触发了回调，这里使用了单个UART1，可以根据实际情况进行扩展。 if (huart == \u0026amp;huart1) { // 清除空闲中断标志位，UART通信中，空闲中断通常用于检测接收结束。 __HAL_UART_CLEAR_IT(\u0026amp;huart1, UART_CLEAR_IDLEF); // 禁用UART发送中断，以防止在处理接收数据时发送数据。 __HAL_UART_DISABLE_IT(huart, UART_IT_TXE); // 检查接收到的数据是否符合预期的协议，如果传输中出错了,就直接跳过不执行,根据协议格式解析数据。 // -1 -2 -3 if (rev_data[0] == 0xFF \u0026amp;\u0026amp; rev_data[2] == 0xFE \u0026amp;\u0026amp; rev_data[4] == 0xFD) { // 从接收到的数据中提取速度、圈数和模式信息。 int speed = rev_data[1]; int circle = rev_data[3]; int mode = rev_data[5]; // 检查速度和圈数是否都不为零，才需要转动。 if (speed != 0 \u0026amp;\u0026amp; circle != 0) { // 如果目标速度和位置都为零，则说明当前没有进行任何动作，可以开始新的动作。 if (Target_Velocity == 0 \u0026amp;\u0026amp; Target_Position == 0) { // 设置目标速度和目标位置。 Target_Velocity = speed; Target_Position = circle * Each_Circle; // 根据模式调用MoTo函数执行相应的操作。 // MoTo 函数定义时要把屏幕传过来的 (0/1) 和 真实转动的对应正确 MoTo(mode); // 启动定时器,这样其他的中断才会发生。 Start_TIM(); } } else { // 如果速度或圈数为零，就说明要停下电机。 MoTo(-2); // 调用MoTo函数执行刹停电机。 // 重置各种参数(防止下次启动时有上次残留的值) 并且 停止定时器。 Stop_TIM(); } } // 重新启用UART发送中断，以便后续可以发送数据。 __HAL_UART_ENABLE_IT(huart, UART_IT_TXE); // 重新启用UART接收中断，以便继续接收数据。 HAL_UART_Receive_IT(\u0026amp;huart1, rev_data, 6); // 清空UART的数据寄存器，以确保不会因为残留数据而触发接收中断。 __HAL_UART_FLUSH_DRREGISTER(\u0026amp;huart1); // 清除UART接收缓冲区非空标志位，以确保下一次接收可以正常触发中断。 __HAL_UART_CLEAR_FLAG(\u0026amp;huart1, UART_FLAG_RXNE); } } // 这里读取encoder有一个坑 // 由于这个encoder是一直累加(或减,取决于电机正反转)的, 它累加到最大值(减到0) 就自动重置了 // 因此你上一次读的数 不一定比 这次读的数大, 这样一算差值, 就可能出现一个极其大的负值 // 为了防止这种情况, 我们就需要把这个 tim 的读数一开始(main里面就设置了) // 就设定到一个 中间数值(0和最大之间), 并且 每次读完之后都把它设定回去 // 这样就能保证每次都得到一个 计算正确的 值 int16_t Read_Encoder(void) { int16_t count = __HAL_TIM_GET_COUNTER(\u0026amp;htim2); TIM2-\u0026gt;CNT = 0x7FFF; count -= 0x7FFF; // 这里因为电机 正传反转 有一种情况是累加,一种是累减, 所以有正有负 // 但是计算pid并设置pwm都是正值, 所以返回绝对值 if (count \u0026lt; 0) { return count * -1; } else { return count; } } int Dead_Voltage = 160; void Set_Pwm(int Velocity) { __HAL_TIM_SET_COMPARE(\u0026amp;htim3, TIM_CHANNEL_3, Velocity + Dead_Voltage); } // 固定时间间隔的 中断控制, 每0.1秒多执行一次 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim == \u0026amp;htim4) { // 读取实际转速(相当于转速) Reality_Velocity = Read_Encoder(); // 转速累和相当于总距离(实际上转速使用这个总距离做差才算出来的,前面已经解释过了) Reality_Position += Reality_Velocity; // 每次先判断是不是已经到了设定的要转的总距离, 如果是, 刹车关定时器重置相关参数 if (Reality_Position \u0026gt;= Target_Position) { // 刹车 MoTo(-2); // 停止计时器 Stop_TIM(); } // 用PID算法计算出要设定的pwm值 Set_Velocity += PID(\u0026amp;pid, Target_Velocity, Reality_Velocity); // 这里串口输出一下调试信息,方便查看 printf(\u0026#34;target: %d, real: %d, set: %d\\n\u0026#34;, Target_Velocity, Reality_Velocity, Set_Velocity); // 设定pwm值 Set_Pwm(Set_Velocity); } } /* USER CODE END 4 */ /** * @brief This function is executed in case of error occurrence. * @retval None */ void Error_Handler(void) { /* USER CODE BEGIN Error_Handler_Debug */ /* User can add his own implementation to report the HAL error return state */ __disable_irq(); while (1) { } /* USER CODE END Error_Handler_Debug */ } #ifdef USE_FULL_ASSERT /** * @brief Reports the name of the source file and the source line number * where the assert_param error has occurred. * @param file: pointer to the source file name * @param line: assert_param error line source number * @retval None */ void assert_failed(uint8_t *file, uint32_t line) { /* USER CODE BEGIN 6 */ /* User can add his own implementation to report the file name and line number, ex: printf(\u0026#34;Wrong parameters value: file %s on line %d\\r\\n\u0026#34;, file, line) */ /* USER CODE END 6 */ } #endif /* USE_FULL_ASSERT */ ","date":"2023-09-18T00:00:00Z","image":"https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/images/cover_hu39448777c4528b1c4251b37c7487b231_783518_120x120_fill_box_smart1_3.png","permalink":"https://canxin121.github.io/p/%E5%B1%8F%E5%B9%95-%E6%8E%A7%E5%88%B6-%E7%94%B5%E6%9C%BApid/","title":"屏幕 控制 电机(pid)"},{"content":"项目地址 -\u0026gt; Spark-GPT Feature 使用Nonebot框架跨适配器实现,多聊天平台同步实现 支持 QQ, QQ频道, Kook, 飞书, Telegram, Discord 支持跨平台账户绑定,多平台账户统一数据 适配多来源语言模型, 多态模型 实现 多用户, 多会话窗口, 公共会话和私有会话 实现 流式输出 , 文转图, 文转网络剪切板链接 实现WebUi编辑配置,实时热更新 ToDo 负载均衡 用户权限系统 模型来源支持情况 ✔️:支持 ❌:不支持\n来源 传入文本 传入图片 输出文本 输出图片 Newbing ✔️ ✔️ ✔️ ✔️ Poe ✔️ ❌ ✔️ ❌ ChatGPT Api ✔️ ❌ ✔️ ❌ ChatGPT 网页 ✔️ ❌ ✔️ ❌ Claude.Ai ✔️ ❌ ✔️ ❌ Slack Claude ✔️ ❌ ✔️ ❌ Ps: 各来源的配置使用均在WebUi中已有详细说明\n聊天平台支持情况 ✔️:支持 ❌:不支持\n来源 传入文本 传入图片 输出文本 输出图片 QQ ✔️ ✔️ ✔️ ✔️ QQ频道 ✔️ ✔️ ✔️ ✔️ Kook ✔️ ❌ ✔️ ✔️ 飞书 ✔️ ❌ ✔️ ✔️ Telegram ✔️ ✔️ ✔️ ✔️ Discord ✔️ ✔️ ✔️ ✔️ Ps: 各聊天平台接入,请查看对应的Nonebot适配器使用说明\n教程 基本概念说明 会话( chat ) 在本插件中,会话指的是 一个独立的由指定模型驱动的聊天上下文\n会话的分类如下:\ngraph TD Chat[\"会话\"] PrivateChat[\"私有会话\"] PublicChat[\"公有会话\"] QPrivateChat[\"QQ的一个和好友的聊天窗口,\\n你们的对话时私有的,\\n别的用户没办法加入到你们的对话中来.\\n为了保证上下文的连贯性,\\n同一个会话必须一问一答.\"] QPublicChat[\"QQ的一个群聊窗口, \\n所有用户都可以使用.\\n但用户是提问者,\\n只有一个 语言模型 是回答者,\\n为了保证上下文的连贯性,\\n语言模型只能 一个一个顺序 回答问题,\\n 不能同时回答你们\"] Chat --\u003e PrivateChat --\u003e |\"类似于\"|QPrivateChat Chat --\u003e PublicChat --\u003e |\"类似于\"|QPublicChat 模型( model ) 在本插件中,模型指的是驱动会话的实际的回复人 模型需要在web ui中配置相关内容才可以启用\n预设( prompt ) 在本插件中,预设指每次新对话开始前,优先加载的人格\n原理:\n基本是在会话开始前,自动先向会话中发送预设文本,也有特殊的来源会使用其他方法\n注意:\n预设 不一定对所有的模型都有效,因为有些模型本身会 阻止这种对模型输出行为的干预 预设 的字数不是越长越好, 字数也会有上限,各模型的上限不一, 超出上限会报错, 只能自行更改预设 指令( command ) 在本插件中,指令指自动填充在问题前面的指令,可以用来命令模型一定的格式或者要求进行回复\n原理: 在发送用户的问题之前,现在用户的问题前面加上指令文本,然后再发送过去 注意:\n指令字数有上限,各模型的上限不一, 超出上限会报错, 只能自行更改指令 基本使用逻辑说明 graph TD CU[\"用户\"] ML[\"获取模型列表\"] PL[\"获取预设列表\"] CmdL[\"获取指令列表\"] CL[\"获取可用会话 (公有 | 私有)\"] CAprivate[\"创建新的会话 (私有 | 公有 {仅管理员} ) \"] CC[\"使用会话\"] CPC[\"回复来继续会话\"] CU --\u003e CL CU --\u003e ML CU --\u003e CmdL CU --\u003e PL ML --\u003e CAprivate CmdL --\u003e CAprivate PL --\u003e CAprivate CL --\u003e CC CAprivate --\u003e CC CC --\u003e CPC 部署教程 部署Nonebot 这里直接看Well404的教程吧,点击即可跳转到b站系列教程 部署各适配器 在这里我直接贴出个适配器的官方使用文档或者合适的教程了\nQQ(OBV11) 首先是qsign的部署,这个目前是 必须的\n然后需要使用 gocq 的dev 版本,这里给出 gocq dev的action地址,可以自行在这里寻找合适的构建版本,\n而连接到nb的方法在上面的 nonebot部署教程中已经又过了,这里不在放出地址\ngocq-dev Action CL\nQQGuid (QQ频道) QQ频道适配器 gh链接\nKOOK(开黑啦) KOOK(开黑啦)适配器 gh链接\n飞书 飞书(Lark)适配器 gh链接\nTelegram Telegram适配器 gh链接\nDiscord Discord适配器 gh链接\n部署Spark GPT 安装插件 1 nb plugin install spark_gpt 配置相关信息 SparkGPT 依赖 nonebot_plugin_web_config 进行实时配置热更新,所以需要配置的相关信息(端口,账号密码),可以点击进入查看相关的env配置. SparkGPT 的GPT来源需要手动配置相应的 auth 信息才可以使用,具体获取方式都均在web ui(默认http://127.0.0.1:8666)中已经标出,并可以实时热更新. 使用教程 使用教程图片版可以使用 shelp 命令获取.\n本插件 均采用Alc命令形式 进行使用.\n在下面的文本中,用{}来标志 需要替换的变量, 用()框起来的为 选填的变量\n会话 使用公有会话询问 格式: public_command{chat_name} {question} ( {photo} )\n参数:\n必填:\nchat_name: 会话昵称 question: 问题 选填:\n3. photo: 需要识别的图片内容,只有model为bing时才可以使用,需要跟随文本信息一同发送 4.\n使用私有会话询问 格式: private_command{chat_name} {question} ( {photo} )\n参数:\n必填:\nchat_name: 会话昵称 question: 问题 选填:\nphoto: 需要识别的图片内容,只有model为bing时才可以使用,需要跟随文本信息一同发送 创建新的会话 格式: chat add -n {chat_name} -m {model} ( -p {prompt} -c {command} -auto_pic {bool} -num_limit {int} -pic {bool} -url {bool} -stream {bool} -public )\n参数:\n必填:\nchat_name: 会话名称 model: 使用的模型名称或者索引数字 选填: prompt:\n使用本地预设,须在预设名称前加\u0026rsquo;.\u0026lsquo;号\n使用自定义预设,直接输入内容 command:\n使用本地指令,须在指令名称前加\u0026rsquo;.\u0026lsquo;号\n使用自定义指令,直接输入内容 auto_pic: 是否当字数过多时自动转图片 num_limit: 自动转图片的字数上限 pic: 是否总是文字转图片 url: 是否在图片或流式回复时发送全文链接 stream: 是否流式输出,分段发送结果 public: 是否是创建共有会话 修改新的会话 格式: chat edit -on {old_name} \\n( -nn {new_name} -m {model} -p {prompt} -c {command} -auto_pic {bool} -num_limit {int} -pic {bool} -url {bool} -stream {bool} -public )\n参数:\n必填:\nold_name: 原来的会话名称 选填: new_name: 原来的会话名称 model: 使用的模型名称或者索引数字 prompt:\n使用本地预设,须在预设名称前加\u0026rsquo;.\u0026lsquo;号\n使用自定义预设,直接输入内容 command:\n使用本地指令,须在指令名称前加\u0026rsquo;.\u0026lsquo;号\n使用自定义指令,直接输入内容 auto_pic: 是否当字数过多时自动转图片 num_limit: 自动转图片的字数上限 pic: 是否总是文字转图片 url: 是否在图片或流式回复时发送全文链接 stream: 是否流式输出,分段发送结果 public: 是否是修改共有会话 获取所有会话的列表 格式: chat list\n删除一个会话 格式: chat del -n {chat_name} ( -public )\n必填:\nchat_name: 会话名称 选填:\npublic: 是否是创建共有会话 模型 获取可用模型列表 格式: model list\n预设 添加一个新的预设 格式: prompt add -n {name} -c {content}\n参数:\n必填:\nname: 预设名称 content: 预设内容 删除一个预设 格式: prompt del -n {name}\n参数:\n必填:\nname: 预设名称 查看预设列表 格式: prompt list ( -p {num} )\n参数:\n选填:\nnum: 页数 查看特定预设具体内容 格式: prompt show -n {name}\n参数:\n必填:\nname: 预设名称 指令 添加一个新的指令 格式: command add -n {name} -c {content}\n参数:\n必填:\nname: 指令名称 content: 指令内容 删除一个指令 格式: command del -n {name}\n参数:\n必填:\nname: 指令名称 查看指令列表 格式: command list ( -p {num} )\n参数:\n选填:\nnum: 页数 查看特定指令具体内容 格式: command show -n {name}\n参数:\n必填:\nname: 指令名称 ","date":"2023-09-10T00:00:00Z","image":"https://canxin121.github.io/p/sparkgpt/cover_hu7099e3869b02a6ea329d45382d6e0a6a_92211_120x120_fill_box_smart1_3.png","permalink":"https://canxin121.github.io/p/sparkgpt/","title":"SparkGPT"},{"content":"项目地址 -\u0026gt; Spark-GPT Nonebot框架 由于SparkGPT由Python开发, 在Python中运行, 而Python目前最佳的bot框架为Nonebot框架,所以 目前2.0.0版本深度绑定Nonebot框架进行开发.\n预计将在下个大版本 将SparkGPT独立实现协议, 再实现不同语言框架的协议对接\n配置管理 webui 实现了Nonebot_plugin_web_config来是实现webui管理配置信息, 借助pydantic的BaseModel来实现序列化反序列化并持久储存和方便的存取.\nNonebot_plugin_web_config提供了一个父类给其他插件,直接继承并填写相关注释和属性即可实现持久储存和web编辑, 并且提供了从Nonebot_plugin_web_config实时获取配置的方法,而无需重新反序列化.\nToDo:\n预计将会实现pydantic -\u0026gt; json schema的转换用于通信, 并重写前端页面\n数据储存 用户会话数据储存 使用pydantic的BaseModel方便 序列化和反序列化 使用Nonebot_plugin_bind的统一id作为用户标志储存, 实现跨平台跨账户的数据共享 所有的会话数据以json形式储存在以用户id命名的文件中, 单用户单数据, 保证数据的隔断性 预设,指令,模型数据 继承自Nonebot_plugin_web_config提供的父类, 直接实现了持久储存和webui编辑 实现了一个装饰器, 方便的给每个子类生成一个从Nonebot_plugin_web_config获取数据的方法 消息事件处理 消息接受 依赖Nonebot_plugin_alconna进行命令形式的消息事件匹配,分发给不同的函数进行处理 实现Nonebot_plugin_bind 进行不同账户(可跨平台)信息的绑定, 将同一人的所有聊天平台的数据统一起来 实现了会话的持久储存和一个从信息中获取会话依赖注入, 可以从一条信息中获取用户私有的或公有的会话, 分发给不同模型的Chatbot处理 回复生成 模型回复 实现BaseChatBot父类, 实现使用 异步生成器 实现 流式发送(每次发送消息的两段左右,如果平台支持编辑消息,那么直接加到原来的消息后面,否则发送新的消息) 和 一次性发送(可以自适应长度文转图转链接, 也可以强制设定使用文字或图片回复), 这里其实就是消息发送的步骤. 所有的ChatBot子类只需添加特有的属性(用于储存会话信息)和BaseChatBot父类要求的属性, 以及一个异步生成器方法(逆向或使用官方api)和一个刷新会话方法, 即可实现一个新的api的接入 涉及的实现的逆向工程的链接\u0026quot; Async-Bing-Client \u0026ldquo;, \u0026quot; Async-Poe-Client \u0026ldquo;, \u0026quot; Async-Claude-Client \u0026quot; 普通回复 菜单和帮助 实现了Nonebot_plugin_templates, 提供一些模板和构造方法, 直接构造出菜单的html并用htmlrender渲染截图返回结果. 实现了一个Menu类来将 文本菜单 和 Nonebot_plugin_templates生成的菜单同时实现, 并且缓存图片, 减小开销, 提高效率 基本查看和管理 chat的list在用户会话数据储存类的基础上加了一个方法, 并借助Nonebot_plugin_templates生成 会话的列表图片并缓存和动态更新, 减少开销, 提升效率 prompt和command的图片回复在Nonebot_plugin_web_config的子类的基础上借助Nonebot_plugin_templates实现图片列表和具体展示 其他文本形式的回复直接发送即可 消息发送 依赖Nonebot_plugin_saa进行跨适配器(跨聊天平台)的发送消息,可以实现图文发送 依赖Nonebot_plugin_htmlrender进行文转图, 实质上就是使用playwright使用我的自制模板进行前端渲染并截图 使用 dpaste.org 的 逆向api 进行文转网络剪切板链接, 方便用户拿去回答和信息 ","date":"2023-09-10T00:00:00Z","permalink":"https://canxin121.github.io/p/sparkgpt-%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/","title":"SparkGPT 思路分析"},{"content":"项目地址 -\u0026gt; Spark-GPT SparkGPT使用示例 Webui 帮助 模型 会话 预设 指令 群二维码 ","date":"2023-09-10T00:00:00Z","permalink":"https://canxin121.github.io/p/sparkgpt-%E9%A2%84%E8%A7%88/","title":"SparkGPT 预览"}]